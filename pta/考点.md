# 模拟
1001：字符串
1002
1005：字符串
1006：字符串
1008
1009
1011
1012：坑点：排队次序其实算个生活常识问题，如果有人成绩相等，例如A(100分)，B(100分)，C(99分)三个人，A和B应当算为并列第1，C算为第3，即 1 1 3，我最初没想这个，按1 2 3来做的，假设想到这个了，但是按照1 1 2 来做还是错的，需要记住这个
1015：题意不是很明确,注意素数判定不要少了数据<2时的判定
1031:
1032：模拟链表结构找到两个链表的第一个公共节点
1035：按着题意模拟做就行了
1036:
1039
1041
1042
1047：模拟，运算仍采用string，但是输入输出需要采用c的字符数组，因此涉及到sting和c字符数组的转化问题，sting读入过慢，需要使用c的字符数组，需要使用string参数为const char *的构造函数和c_str用于输出string

# dfs
1003
1013：dfs统计连通块数量，当然分析到统计连通块数量还需要一定的思想过程
1018：一部分dfs，还需要搭配剪枝，另一部分是图上最短路，比较不好写的一道题

# 图最短路
1018：一部分最短路，还需要结合dfs及剪枝，比较不好写的一道题，非常离谱的一道题目，最后一个数据点必须在dijkstra时候保存下前驱节点，在dfs时仅枚举前驱节点，仅通过二进制标记都没用，因为枚举时还是枚举了所有点，但是按理说搜索空间已经减少了啊，最后一个点真的是神仙数据，不过只有1分，考试时万万不可为了这1分浪费这么多时间
1030:先跑一遍最短路，然后dfs找到所有最短路维护最小开销

# 树
1004：bfs层序遍历
1020:根据后续遍历和中序遍历输出层序遍历：知道思路后不难上手写代码，但是对于数据的处理方法本来可以直接通过运算获得的我没想到，而是去遍历获取，树的遍历在结果上存在一定的性质，有些数据的获取要取巧,真是没想到，毫无优化的暴力写法3750ms可以过，加上很巧妙思想的写法27ms居然某个点内存超限，所以考试的时候千万别觉得不应该暴力解决就不去写，它这个数据我真的是服了，毫无优化的写法居然比带优化的跑得快，我真的无语，考试的时候千万别觉得你的想法过不了，可能它考的真的没那么难
1043：二叉搜索树的先序遍历合法性判定顺便转后序遍历，递归模拟，按照建树的流程进行，需要想清楚是不是镜像是由我们决定的，而不是根据数据决定的，同一个数据既可以是镜像也可以是非镜像，最开始就是这一点想错了

# dp
1007：简单dp思想

# 字符串
1040：本题由于数据范围较小，可以直接暴力，线性解法有点复杂暂时先放一放

# 二分
1010：坑点：进制转换的上限值容易想错，有些数据会爆long long，要通过判断是否<0来判断，这个真的是很坑人的
1044：需要预处理一下前缀和

# 进制转换
1019：
1027: upper-cased是大写，第一次写成了小写，输入数据包含0，需要特判一下 

# 高精度
## 高精度加
1024：需要考虑本身是回文答案是0，即不需要进行操作
## 高精度乘
1023：高精*低精

# 语法题
1025：考察结构体的使用和sort排序，sort排序要么使用cmp要么重载运算符 [结构体初始化和赋值区别](https://blog.csdn.net/k346k346/article/details/51537077)
1028: 结构体的使用，为了代码的简洁还可以使用lambda表达式和function函数模板，如果vector使用emplace_back还需要写类的带参构造函数
1039:

# 排序
1029：sort一下就可以了
1037
1038：排序的同时还涉及到数据前导0的处理

# 贪心
1033：这个贪心思路看似很好像，但是细节比较多，代码实现也比较复杂，而且是double运算，写着心里很没底

# 连通块
1034：统计连通块内信息，使用并查集比较方便一些，期间涉及到一点点图的遍历

# 前缀和
1046：

# 注意点
1. pta上有些题目数据没有那么强，考试即使明知道自己的想法有点蠢，但如果实在想不到怎么写还是试一试，没准就过了
2. 在一行的输出中最后一个不应该是空格，需要把空格输出到两个数中间
3. 考试一定把存储结构想清楚了再写代码，1043没考虑到节点的值会重复，直接拿值当节点id，写完代码才发现这个问题，额外引入结构体存储节点，所有代码都需要变动，太浪费时间
4. 1043虽然就错了2个点，但是可以发现其实是最开始的解题思路是完全错误的，根据实际情况考试给自己限定一个时间，如果时间内没有想到这2个点的可能错误原因，就暂时性放弃吧，因为错误原因可能是惊人的