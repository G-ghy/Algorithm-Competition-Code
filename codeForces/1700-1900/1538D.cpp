/**
 * https://codeforces.com/problemset/problem/1538/D
 * 不难想到质因数分解，观察分解后的结果，例如36和48
 * 36 = 2 * 2 *             3 * 3
 * 48 = 2 * 2 * 2 * 2 *     3
 * 若想要两个数变相等，最少的操作方法是36去掉一个3，48去掉两个2，即最少要2步，最多是9步，把两个数全部变为1且每次仅除以一个质因子
 * 所以当k>=2 && k<=9时答案为Yes，反之为No
 * 
 * 即我们首先需要对两个数进行质因数分解，统计每个质因子个数
 * 然后计算不同数量质因子的个数，对于上述例子，36和48的质因子2个数不同，计数器+1，质因子3个数不同，计数器+1
 */

#include <iostream>
#include <cstring>

using namespace std;

void decompose(int x, int &cntx)
{
    for (int i = 2; i * i <= x; ++i)
        while (!(x % i))
        {
            ++cntx;
            x /= i;
        }
    if (x != 1) ++cntx;
}
int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        int a, b, k;
        cin >> a >> b >> k;

        int cnta = 0, cntb = 0;
        decompose(a, cnta); decompose(b, cntb);

        // int type = 0, cnta = 0, cntb = 0;
        // for (int i = 2; i < N; ++i)
        // {
        //     cnta += ap[i];
        //     cntb += bp[i];
            // if (ap[i] != bp[i]) ++type;
        // }
        
        /**
         * 错误数据
         * 1
         * 36 6 1
         * 输出结果为No，正确结果为Yes
         * 36 = 2 * 2 * 3 * 3
         * 6 = 2 * 3
         * 按照type的思想，至少需要2次操作才可使得两数相等
         * 如果是
         * 2          *3 * 3
         * 2 * 2      *3
         * 这种形式，确实需要两次，但是多出来的2和3恰好同时出现在一边就不再需要2次了，1次就够了
         */
        // int min;
        // if (type == 1) min = 1;
        // else min = 2;
        // if (k >= min && k <= cnta + cntb) flag = true;
        // else flag = false;
        /**
         * 很容易想到质因数分解
         * 很容易看出的合法操作的上限值
         * 那很自然的会去想下限是多少
         * 那很自然会去想不同情况下的合法下限值
         * 这怎么会往k的角度去想呢？
         * 往k上去想可能是因为想到了
         * 两个数最少用2次就可以全部变为1了(很简单的性质但我还真没想到这回事)
         * 所以当k>=2时，只要k没有超过它的上限值就可以保证一定能把两个数变得相等
         * 因此再单独判断下k==1就行了
         * 我觉得我没有想到正解的问题在于，我没有正确认识到两个数最少用2次就可以解决了，上来就陷入了质因数分解结果的那堆数中，总是在分析各个质因子的个数
         * 
         * 对于k==1，只有在两个数是倍数关系并且不相等时才可以仅在一步内变相等
         * 因为想要1次就相等，那么对于两个数考虑质因数分解之后的结果，较大值每个质因子个数一定要大于较小值，
         * 一旦较小值的某个质因子个数多于较大值了，那么较小值去掉那个多出来的质因子至少还需要一步，那最小就是2步了
         * 同时，仅一次就想相等要求需要有较大值和较小值，这样通过1次操作消掉较大值中多出来的质因子两数就相等了
         * 如果两数相等，为保证操作后两数仍然相等，必须保证两者的操作是同步的，那至少要2步
         */
        bool flag = (k == 1) ? ((b % a == 0 || a % b == 0) && a != b) : (k <= cnta + cntb);
        
        if (flag) cout << "Yes" << endl;
        else cout << "No" << endl;
    }

    return 0;
}