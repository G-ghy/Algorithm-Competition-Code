#include <cstring>
#include <cstdio>
#include <cmath>
#include <iostream>
#include<string>
#include <algorithm>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <set>
#include <map>
#include <unordered_map>
#include <unordered_set>

using namespace std;

constexpr int N = 1e5 + 10;
constexpr int INF = 0x3f3f3f3f;

// 两种想法
// 第1种
// 首先要发现的是当高度处在两个矩形中间时是不需要考虑的，例如高度依次为5 2，那么2以下的高度不需要考虑，2到5之间的高度不需要考虑
// 因为在矩形中间的过程中状态并不会发生改变，发生改变的情况是没有没过2的状态向没过2的状态发生改变时和没有没过5的状态向没过5的状态发生改变时
// 只有状态发生变化的高度才是我们需要考虑的，我们将这种高度称为状态改变的高度
// 也就是说我们只需要枚举读入的各个高度，然后考虑如何计算在雨水达到这个高度时形成的岛的数量
// ---------------------------------------------------------------------------------
// 以上过程经过一些思考还是有想出来的可能性的，但是之后就不知道怎么做了
// 因为面对的情况并不明朗，感觉会有很多的问题，这时候有个很重要的方法就是分类讨论
// 我总是不知道分类讨论，很多看起来乱的问题如果经过分类讨论就可以逐一击破
// 还需要注意的是分类讨论从大体上符合分类即可，不要涉及到太多特殊情况，否则你会发现这题就想不出来了
// 因为很多时候一些特殊情况是独立于分类讨论的之外的，也就是说要在分类之后单独想办法解决，如果放在分类讨论中就会更乱了
// 考虑一个矩形的可能情况，考虑一个矩形两边的高度和它的高度之间的关系，也就是考虑中间的矩形状态发生改变
// ·左边比它高
//      · 右边比它高：发生状态转变时岛数量-1，因为没有淹没中间矩形时只有是1个岛，淹没后被分成了左右2个岛屿，所以答案数+1
//      · 右边比它低，答案数量不变
// · 左边比它低
//      · 右边比它高，答案数不变
//      · 右边比它低，答案数-1
// 需要注意的是上面的讨论中并没有涉及到和中间矩形高度相等的情况，考虑一下如果相等应该怎么计算
// 比如说高度序列是4 2 2 ... 比如说到了第一个2，后面的矩形和它高度相等，这样导致的就是第二个2后面的情况是未知的，我们无法用上面4中情况进行划分
// 但是还可以发现的是，如果雨水高度达到2时，两个高度为2的矩形是同荣辱共进退的，两个矩形完全可以等价为一个矩形，即进行所谓的缩点操作即可
// 体现在代码上就是进行一次去重操作(需要注意的是去重是去除相邻的相等的数而非每个高度仅留下一个，因为比如说4 2 5 2，这样的两个2可以进行划分，不需要去重)，这样的去重要求可以采用双指针逻辑的unique函数实现
// 然后枚举各个读入的高度根据上述4种情况进行计算，需要注意的是我并没有强调一定要从小到大枚举高度，从逻辑上来讲雨水的高度的确应该从小到大的
// 但是可以发现上述4种分类时仅仅是根据左右相邻的高度，先枚举高度较高的和先枚举高度较低的对与答案的计算并没有什么影响
// 不过，还是要按照从小到大或者从大到小的顺序先排序然后再计算，因为在考虑完一个高度后需要与现有最大岛屿数量进行比较
// 对于4 2 5 2这种情况，假设考虑高度为2，这时候应该是把2个高度为2的矩形同时考虑完成后才可以更新答案，而不能先计算完第一个2然后更新一次答案，然后计算第二个2再更新一次答案
// 假设第一个计算完成后结果大于当前答案，而第二次计算会是使得结果等于当前答案，高度为2的两个矩形应该是共进退的，实际并不会对答案进行更新，所以需要把高度为2的两个矩形放在一次计算
// 所以才需要进行排序
// 也就是说排序并不单纯为了模拟雨水从少到多的过程，而是为了处理不相邻的相同高度矩形
// 不过实际做题时未必会想到这一层，就从模拟雨水高度从少到多还更好理解
int h[N];
pair<int, int> q[N]; // {h[i], i} : 按照第一维高度进行排序，第2维保留序号方便查找一个矩形相邻矩形的高度

void solve1() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> h[i];

    n = unique(h + 1, h + n + 1) - h - 1;
    h[n + 1] = 0; // 去重后，h[n + 1]可能还是原来的数值，无论是从符合逻辑的角度还是从代码方便的角度置为0都是更好的

    // cout << "------" << endl;
    // for (int i = 1; i <= n; ++i) cout << h[i] << ' ';
    // cout << endl;

    for (int i = 1; i <= n; ++i) q[i] = {h[i], i};

    sort(q + 1, q + n + 1);

    int res = 1, cnt = 1;
    for (int i = 1; i <= n; ++i) {
        int j = q[i].second;
        if ((h[j - 1] > h[j]) && (h[j + 1] > h[j])) ++cnt;
        else if (h[j - 1] < h[j] && h[j + 1] < h[j]) --cnt;
        // cout << h[j - 1] << ' ' << h[j] << ' ' << h[j + 1] << endl;
        // cout << j << ' ' << cnt << endl;
        if (q[i].first != q[i + 1].first) res = max(res, cnt);
    }

    cout << res << '\n';
}

// 第2种
// 
void solve2() {

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    // solve1();
    solve2();
    return 0;
}